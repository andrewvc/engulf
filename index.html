<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Engulf - Dead Simple Open Source HTTP Load Tester</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script>
    <script type="text/javascript" src="main.js"></script>
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1><span>Engulf</span></h1>
        <p><strong>High Performance HTTP Load Testing</strong></p>

        <ul class="downloads">
          <li><a href="http://engulf-project.s3.amazonaws.com/releases/engulf.jar">Download <strong>3.0.0-beta11 JAR</strong></a></li>
          <li><a href="#amazon-ami">Launch <strong>AWS AMI</strong></a></li>
        </ul>
        
        <h3>Learn More</h3>
        <ul id="sidemenu" class="sections-toc">
          <li><a href="#about">About Engulf</a></li>
          <li><a href="#usage">Usage</a></li>
          <li><a href="#amazon-ami">Instant AWS Cluster</a></li>
          <li><a href="#http-api">REST/Streaming API</a></li>
        </ul>
        
      </header>
      <section>
<h2 id="about">About</h2>
<p class"intro">Engulf is a <em><strong>scalable and distributed HTTP benchmarker</strong></em>, designed to let you spin up and coordinate a cluster of workers with nothing more than a single JAR. Engulf's backend is written in clojure, the frontend in javascript. Engulf is fully open-source.</p>

<p>Features Include:</p>

<ul>
<li>Realtime browser UI</li>
<li>Clustering</li>
<li>Recording/Annotation of all test runs</li>
<li>An <a href="#amazon-ami">AWS AMI</a> for instant provisioning</li>
<li><a href="#http-api">REST and Streaming API</a>
<li><a href="http://blog.andrewvc.com/markov-http-benchmarking">Markov request pattern generation</a></li>
</li>
<li>Minimalism and ease of use as a pervasive goal</li>
</ul>

<em>The Web UI in action</em>:
</ul><p><img src="screenshot.png" alt="Screenshot"></p>

<h2 id="usage">Usage</h2>

<h3>Quickstart</h3>

<ol>
<li><strong>Make sure you're running <a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">JDK 7</a>, *not* JDK 6. You will get strange errors otherwise</strong>. You can check this by running <code>java -version</code> in a terminal. The output should look something like <code>java version "1.7.XXXX"</code></li>
<li>This only runs in google chrome at the moment</li>
<li>Download the jar from the <a href="https://github.com/andrewvc/engulf/downloads">downloads page</a>
</li>
<li>Run it like so <code>java -server -jar engulf-VERSION.jar</code>
</li>
<li>Visit http://localhost:4000 in your browser to use the GUI</li>
<li>See the wiki page on <a href="https://github.com/andrewvc/engulf/wiki/Usage">usage</a> for more details.</li>
</ol>

<h3>Client / Server Configuration</h3>

<p>
Client/server configuration of Engulf is simple. One master node is started which will listen on port 4025. Then, any number of worker nodes maybe started that point to the master. See the example below:</p>

<p>Starting the master<br><code>java -server -jar engulf.jar --mode master</code></p>

<p>Starting a worker<br><code>java -server -jar engulf.jar --mode worker --connect-to 127.0.0.1:4025</code></p>

<h3>CLI Opts</h3>
<pre>Switches           Default             Desc                      
 --http-port        4000                Listen on this port for the HTTP UI                
 --manager-port     4025                TCP Port for manager to listen on                  
 --mode             :combined           {combined:master:worker}                           
 --connect-to       ["localhost" 4025]  When in worker mode, connect to this TCP host:port 
 --no-help, --help  false               Show help, then exit                               
</pre>

<h3 id="#backup">Backing up Saved Data</h3>

<p>All data is saved to <code>$HOME/.engulf.sqlite3</code> on the master node. If you wish to back this up be sure to stop any running instances and make a copy of this file.</p>

<h3>Tuning OS Settings</h3>

<p>Engulf opens a lot of ports very quickly, most OSes have default limits that conflict with that, especially when keep-alive is disabled. To combat this, consider upping your system's max open files via ulimit, and increasing its ephemeral port range.</p>

<h3>Warming Up Engulf</h3>

<p>Engulf is fastest after a few short test runs. You will notice gets faster after a boot given a few test cases. This is due to the fact that Engulf is written in <a href="http://clojure.org/">Clojure</a> which runs on the Java Virtual Machine. The HotSpot JIT recompiles code as it runs, making code progressively faster leading to this phenomenon.</p>

<h2 id="amazon-ami">Instant AWS Cluster</h2>

<h3>About Cloud Load Testing with AWS</h3>

<p>Perhaps the easiest way to start up Engulf is with Amazon Cloudformation. The CloudFormation templates will setup either a single instance, or cluster of instances with just a few clicks, along with any security and scaling groups as required. These instances are based on a custom AMI with tuned operating system and JVM settings for optimal performance.</p>

<h3>Launching a Single Instance</h3>

<p><a href="https://console.aws.amazon.com/cloudformation/home?region=us-east-1#cstack=sn~EngulfSolo|turl~http://engulf-project.s3.amazonaws.com/engulf-solo.template.json" target="_blank">Click here</a> to launch a single instance of Engulf. Click 'continue' on the first screen, then simply fill in the size of instance when prompted. Be sure to use the API name for a given instance type <a href="http://aws.amazon.com/ec2/instance-types/">from this list</a>.</p>

<p>When the CloudFormation template is done running, check its output pane on the Amazon Console. There should be a field labeled "URL", with a corresponding URL to its right. Open the URL in your browser to use the web interface.</p>

<p>Please note, all data is saved on the EBS node of your EC2 instance. If you wish to save that data for later make sure to never terminate the instance, but rather to only stop and start it. For other options Read the section on <a href="#backups">backups</a>.</p>


<h3>Launching a Cluster</h3>

<p><a href="https://console.aws.amazon.com/cloudformation/home?region=us-east-1#cstack=sn~EngulfCluster|turl~http://engulf-project.s3.amazonaws.com/engulf-cluster.template.json" target="_blank">Click here</a> to launch an Engulf cluster using CloudFormation. Click continue on the first screen. The number of desired workers can be specified up-front, as can the instance sizes of the workers and masters. Please use an instance type from <a href="http://aws.amazon.com/ec2/instance-types/">this list</a>. Workers can be scaled up and down by re-running the CloudFormation template (just click the link above a second time and alter the number of nodes).</p>

<p>You may not want to keep the full cluster running at all times. If you do not mind losing data simply delete the CloudFormation stack. If you would like to keep your data around the best strategy is to, in the EC2 console, 'stop' the master node and 'terminate' the workers. This leaves your data intact on the master, and discards the workers which have no data. To start it back up again, start the master and wait for it to fully boot. Then, visit the <a href="https://console.aws.amazon.com/cloudformation/home?region=us-east-1">cloud formation home</a>, select 'EngulfCluster', click 'Update Stack', select 'Provide a Template URL', and paste in <code>http://engulf-project.s3.amazonaws.com/engulf-cluster.template.json'</code></p>

<h4>About the AMI</h4>

<p>If you would like to build your own custom cluster on AWS feel free to make use of the custom AMI (<a href="https://console.aws.amazon.com/ec2/home?region=us-east-1#launchAmi=ami-5f2a9f36">ami-5f2a9f36</a>) used by the CloudFormation recipes.</p>

<p>The pre-built Engulf AMI is configured with all the correct dependencies, will always use the latest version of Engulf, uses tuned kernel settings, and uses tuned JVM settings for optimal performance. Options for Engulf can be passed through the user-data option when booting.</p>

<h3>Launching a Single Instance</h3>

<ol>
<li>Click <a href="https://console.aws.amazon.com/ec2/home?region=us-east-1#launchAmi=ami-5f2a9f36">this link</a> to launch the AMI</a></li>
<li>In the AMI wizard fill in any values you please, but be sure to leave the user data portion of the wizard blank</li>
<li>Point your browser toward: <code>http://ec2yourinstance.compute1.amazonaws.com:8080</code></li>
</ol>

<h3>Launching a Cluster</h3>

<p>
In an Engulf cluster you must provision a single master and multiple workers.
</p>

<h4>Provisioning the Master</h4>

<ol>
<li>Click <a href="https://console.aws.amazon.com/ec2/home?region=us-east-1#launchAmi=ami-5f2a9f36">this link</a> to launch the AMI</a>. When you get to the user data section of the wizard, proceed to the next step.</li>
<li>In the user data section of the wizard enter: <pre>--mode master</pre></li>
</ol>

<h4>Provisioning the Workers</h4>

<ol>
<li>Click <a href="https://console.aws.amazon.com/ec2/home?region=us-east-1#launchAmi=ami-5f2a9f36">this link</a> to launch the AMI</a>. You may select as many machines as you want if you desire multiple workers. When you get to the user data field in the wizard proceed to the next step.</li>
<li>Take note of the <strong>master's internal hostname</strong>, which should look something like:<br> <code>ip-0-0-0-0.ec2.internal</code>. You will need this for the next step.</li>
<li>In the instance launch wizard, in the user data section enter: <pre>--mode worker --connect-to MASTER-INTERNAL-HOSTNAME:4025</pre> <strong>Don't forget to append ':4025'</strong> to the hostname!</li>
</ol>

<h4>Using the Cluster</h4>

<p>Simply point your browser at</p>
<p><code>http://yourmasterinstance.compute1.amazonaws.com:8080</code></p>
<p> You should see a number of nodes matching the number of workers you've started up. If the number of nodes is indicated as 0 something is off!</p>

<h3>SSHing in and Backing up Saved Data</h3>

<p>All data in the Engulf VM is persisted to <code>/home/ubuntu/.engulf.sqlite3</code> on the master node. You can ssh into the node using your provisioned key as the 'ubuntu' user.</p>

<p>Either make sure to keep the master's EBS Volume around, or make sure to backup this file yourself (you probably want to kill any active Engulf processes if manually backing up before doing this).</p>

<p>Engulf can be started/stopped by executing <code>sudo /etc/init.d/engulf stop</code>. It can be started again with <code>sudo /etc/init.d/engulf start</code></p>


<h2 id="http-api">REST / Streaming API</h2>

<div class="markdown-body">

<h3>Jobs</h3>

<ul>
<li><a href="#wiki-job-start">Starting a Job</a></li>
<li>
<a href="#wiki-job-stop">Stopping the Current Job</a> </li>
<li><a href="#wiki-job-list">Listing Jobs</a></li>
<li><a href="#wiki-job-get">Retrieving a Job</a></li>
<li><a href="#wiki-job-delete">Deleting a Job</a></li>
</ul>

<h3>River</h3>

<ul>
<li><a href="#wiki-river">Understanding the River API</a></li>
</ul>

<h3>Nodes</h3>

<ul>
<li><a href="#wiki-node-list">Listing Nodes</a></li>
<li><a href="#wiki-node-get">Retrieving a Node</a></li>
</ul>

<h3>Job API</h3>

<p>Each benchmark executed is represented by a single job, with multiple nested results in this REST API.</p>

<h3 id="wiki-job-start">Starting a Job</h3>

<p><code>POST /jobs/current</code> <em>+ JSON Body</em></p>

<p>A new benchmark can be started by issuing a POST request to <code>/jobs/current</code> with a JSON body of parameters. The parameters for jobs are:</p>

<p><strong>Parameters:</strong></p>

<ul>
<li><strong>title:</strong> MAY be set. Stored as job metadata. Maxlen 255</li>
<li><strong>notes:</strong> MAY be set. Stores as job metadata. Size unbounded</li>
<li>
  <strong>_stream:</strong> MAY be set. If set to <code>true</code> the HTTP connection will stay open while the benchmark is running, and stream results back in chunks. If set to <code>false</code> it will return the job metadata immediately.
</li>
<li><strong>params.url:</strong> MAY be set. The full URL to test, e.g., http://localhost/bar. It must <em>ALWAYS</em> include the host and protocol. If this is not set, markov-corpus must be set.</li>
<li><strong>params.markov-corpus:</strong> MAY be set. If you'd like to test a list of URLs use this option.<br>The list is analyzed and traversed as a <a href="http://www.beetleinabox.com/markov.html">markov-chain</a> for a good mix between randomness and similarity to a given source. Taking a snippet out of a webserver log is a good way to use this.<br> The should must passed in as a JSON array of either strings (simple get requests) or hashes of the form {"url": "http://...", "method": "post"}.</li>
<li><strong>params.limit:</strong> MUST be set. The job will stop at this point. Note, due to performance optimizations there is no guarantee Engulf will stop at this exact mark. It will merely attempt to stop at it, but will usually over-run it by a small amount.</li>
<li><strong>params.concurrency:</strong> MUST be set. The desired number of concurrent requests <em>cluster-wide</em>. So, if you have 2 workers, a setting of 10 means there will be 10 simultaneous requests at any given time, with 5 on each worker.</li>
<li><strong>params.formula-name:</strong> MUST be set. Currently always "http-benchmark".</li>

<li>
  <strong>params.target:</strong> MUST be set. Is a dictionary describing the URL or URLs to hit with the following values.
  <hr>
  <p><strong>Single URL Targets</strong>
  <pre>{
  "type": "url",
  "url": "http://example.net",
  "method": "get",     // Can be get/post/put/patch/delete
  "timeout": 1000,     // Optional, defaults to 30000ms
  "keep-alive": "true" // required, either "true" or "false" as strings
}</pre>

  <p><strong>Markov URL Targets</strong>
    See <a href="http://blog.andrewvc.com/markov-http-benchmarking">this blog post</a> for more information on markov HTTP testing in general. Each dictionary in the corpus takes the same arguments as a single URL does. Per client opts (like keep-alive) are derived from the first URL in the list. It also supports an abbreviated syntax, where only the URL is used in lieu of a dictionary. A GET request is assumed in this case.
  <pre>{
  "type": "markov",
  "corpus": [{"url": "http://example.net/a", "method": "get", "keep-alive": "true"}
             {"url": "http://example.net/b", "method": "get"},
             "http://example.net/simple"]
}</pre>
  </p>
</li>


 
</ul><p><strong>Examples:</strong></p>

<div class="highlight"><pre><span class="c"># Testing a single URL</span>
curl -XPOST http://localhost:4000/jobs/current -H 'Content-Type: application/json' -d '{
"title": "A Simple Test", "_stream":"true",
"params": {"formula-name":"http-benchmark", "concurrency":5, "limit":50000,
    "target": {"type": "url", "url": "http://localhost:8081", "keep-alive":"true", "timeout":50, "method":"get"}}}'
</pre></div>

<div class="highlight"><pre><span class="c"># An example of testing using a markov-chain</span>
curl -XPOST http://localhost:4000/jobs/current -H 'Content-Type: application/json' -d @markov.json</pre>

In markov.json:
<pre>{
    "title": "a test",
    "_stream": "true",
    "params": {
      "formula-name": "http-benchmark",
      "concurrency": 5,
      "timeout": 50,
      "limit": 50000,
      "keep-alive": "true",
      "target": {
        "type": "markov",
        "corpus": [
            "http://localhost:8081/foo",
            "http://localhost:8081/bar",
            "http://localhost:8081/bar",
            "http://localhost:8081/baz",
            {
                "method": "POST",
                "url": "http://localhost:8081/fancy"
            },
            "http://localhost:8081/foo",
            "http://localhost:8081/baz",
            {
                "method": "POST",
                "url": "http://localhost:8081/fancy"
            },
            "http://localhost:8081/foo",
            "http://localhost:8081/foo",
            {
                "method": "POST",
                "url": "http://localhost:8081/fancy"
            }
        ]
    }
  }
}</pre>
</div>

<h3 id="wiki-job-stop">Stopping the Current Job</h3>

<p><code>DELETE /jobs/current</code></p>

<p>Stops the currently running benchmark instantly. Returns a representation of the job.</p>

<p><strong>Example:</strong> <code>curl -XDELETE http://localhost:4000/jobs/current</code></p>

<h3 id="wiki-job-list">Listing Jobs</h3>

<p><code>GET /jobs</code></p>

<p>Returns a paginated list of jobs. This will only return the job metadata. To retrieve results, view the <a href="#wiki-job-get">job-get</a> API below.</p>

<p><strong>Parameters:</strong></p>

<ul>
<li>
<strong>page:</strong> Starting from 1, the page number to retrieve.</li>
<li>
<strong>per-page:</strong> The number of results per-page</li>
</ul><p><strong>Example:</strong> <code>curl http://localhost:4000/jobs?page=1&amp;per-page=10</code></p>

<h3 id="wiki-job-get">Retrieving a Job</h3>

<p><code>GET /jobs/UUID</code></p>

<p>A single job can be retrieving at <code>/jobs/UUID-HERE</code>. It will include all the results nested inside of it.</p>

<p><strong>Example:</strong> <code>curl http://localhost:4000/jobs/ef3062e1-7abc-4769-a96c-a654c4219f5c</code></p>

<h3 id="wiki-job-delete">Deleting a Job</h3>

<p><code>DELETE /jobs/UUID</code></p>

<p>This will attempt to delete the job specified by uuid at <code>/jobs/UUID-HERE</code>. Jobs that are currently still running cannot be deleted, and will return an HTTP status of <code>409 - Conflict</code>. </p>

<p><strong>Example:</strong> <code>curl -XDELETE http://localhost:4000/jobs/ef3062e1-7abc-4769-a96c-a654c4219f5c</code></p>

<h2>River API</h2>

<h3 id="wiki-river">Understanding the River API</h3>

<p><code>GET /river</code> <em>supports websockets</em></p>

<p>The river API consists of a single endpoint <code>/river</code> that understands both plain GET and WebSocket requests. Either way, it returns a stream of JSON messages representing state-changes and results within Engulf.</p>

<p>Most messages sent through the River API utilize the <a href="http://en.wikipedia.org/wiki/Entity%E2%80%93attribute%E2%80%93value_model">EAV Pattern</a>, and have a format that consists a map of the format: {"entity", "msg-entity" "name": "msg-name", "body", "msg-body"}. </p>

<p>It should be noted that the River API consists only of deltas of nodes and job state changes. The initial request to <code>/river</code> will return messages named <code>"current-nodes"</code> and <code>"current-jobs"</code> respectively. These are a snapshot of the current state of both resources. Messages received subsequently should alter the local state of clients accessing these resources.</p>

<p>More documentation about the River API is on the way, but a reasonable understanding can be gleaned by watching the output of <code>curl /river</code>.</p>

<h2>Node API</h2>

<p>Information about connected worker nodes can be retrieved via this REST API.</p>

<h3 id="wiki-node-list">Listing Nodes</h3>

<p><code>GET /nodes</code></p>

<p>Returns a list of all connected nodes.</p>

<p><strong>Example:</strong> <code>curl http://localhost:4000/nodes</code></p>

<h3 id="wiki-node-get">Retrieving a Node</h3>

<p><code>GET /nodes/UUID</code></p>

<p>Returns the metadata for a single connected node.</p>

<p><strong>Example:</strong> <code>curl http://localhost:4000/nodes/a-uuid-here</code></p>
</div>


<h2 id="todo">Todo:</h2>

<ul>
<li>Embedded JS Engine</li>
<li>Browsing past jobs in the UI</li>
<li>Targetting subsets of nodes</li>
</ul>


<h2 id="thanks">Thanks!</h2>

<p>
I'd like to thank <a href="http://ideolalia.com/">Zach Tellman</a>, who's work on the fantastic <a href="https://github.com/ztellman/aleph/">aleph</a> library made much of Engulf possible. I'd also like to thank <a href="http://trentstrong.com/">Trent Strong</a> for the idea of generating requests with Markov chains.</p>

<p>I'd like to thank YourKit for providing this project with their Java profiler (which works excellently with Clojure).
It's great at spotting performance issues. More info below:</p>

<p>YourKit is kindly supporting open source projects with its full-featured Java Profiler.
YourKit, LLC is the creator of innovative and intelligent tools for profiling
Java and .NET applications. Take a look at YourKit's leading software products:
<a href="http://www.yourkit.com/java/profiler/index.jsp">YourKit Java Profiler</a> and
<a href="http://www.yourkit.com/.net/profiler/index.jsp">YourKit .NET Profiler</a></p>


<h2>License</h2>

<p>Copyright (C) 2011 and 2012 Andrew Cholakian</p>

<p>Distributed under the Eclipse Public License, see LICENSE for details</p>
      </section>
      <footer>
        <p>Maintained by <a href="http://blog.andrewvc.com">Andrew Cholakian</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Adapter from a theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
<!--
              <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-17399267-5");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>
-->
  </body>
</html>
